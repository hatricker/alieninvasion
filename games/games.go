package games

import (
	"log"
	"strings"

	"github.com/hatricker/alieninvasion/generators"
)

//Game keeps game state
type Game struct {
	AlienLocations map[string]string
	CityMap        map[string]*generators.CityNode
	randGen        generators.NumGen
}

func spreadAliensOntoMap(aliens []string,
	cityMap map[string]*generators.CityNode,
	gen generators.NumGen) map[string]string {
	if len(aliens) > len(cityMap) {
		log.Panic("aliens size must not larger than number of cities")
	}
	alienLocations := map[string]string{}
	cityNames := make([]string, 0, len(cityMap))
	for cn := range cityMap {
		cityNames = append(cityNames, cn)
	}

	for _, alien := range aliens {
		num := gen.GenerateNum(len(cityNames))
		cn := cityNames[num]
		alienLocations[alien] = cn
		cityMap[cn].Aliens = append(cityMap[cn].Aliens, alien)
		cityNames = append(cityNames[:num], cityNames[num+1:]...)
	}

	log.Printf("Alien on the map: %v", alienLocations)
	return alienLocations
}

//NewGame initializes game state
func NewGame(aliens []string, cityMap map[string]*generators.CityNode, gen generators.NumGen) *Game {
	game := &Game{CityMap: cityMap, randGen: gen}

	game.AlienLocations = spreadAliensOntoMap(aliens, cityMap, gen)
	return game
}

//StartGame starts the game
func (g *Game) StartGame(loop int) {
	for i := 0; i < loop; i++ {
		if len(g.AlienLocations) == 0 {
			//no aliens on the map, stop
			break
		}
		moves := g.GenMoves()
		log.Printf("Move #%d: %v", i, moves)
		g.MakeMove(moves)
		g.CheckAndDestroy()
	}
}

//GenMoves generates the moves for each aliens
func (g *Game) GenMoves() map[string]int {
	moves := make(map[string]int)
	for alien := range g.AlienLocations {
		random := g.randGen.GenerateNum(4)
		direction := 1 << random
		moves[alien] = direction
	}
	return moves
}

//MakeMove updates the game state based on the moves input
//moves are generated by some generator. It's a map between
//alien's name and direction to move. Please see DirectionBitMap
//in maps.go for definition of directions
func (g *Game) MakeMove(moves map[string]int) {
	for alien, city := range g.AlienLocations {
		direction, ok := moves[alien]
		if !ok {
			continue
		}
		cityNode, ok := g.CityMap[city]
		if !ok {
			continue
		}
		var nextCity *generators.CityNode
		switch direction {
		case generators.East:
			if cityNode.East != nil {
				nextCity = cityNode.East
			}
		case generators.West:
			if cityNode.West != nil {
				nextCity = cityNode.West
			}
		case generators.North:
			if cityNode.North != nil {
				nextCity = cityNode.North
			}
		case generators.South:
			if cityNode.South != nil {
				nextCity = cityNode.South
			}
		}
		if nextCity != nil {
			log.Printf("Alien [%s] moved from <%s> to <%s>", alien, city, nextCity.Name)
			nextCity.Aliens = append(nextCity.Aliens, alien)
			g.AlienLocations[alien] = nextCity.Name

			//Clear city node alien array
			g.removeAlienFromCity(city, alien)
		}
	}
}

func (g *Game) removeAlienFromCity(city, alien string) {
	var i int
	node := g.CityMap[city]
	for i = range node.Aliens {
		if node.Aliens[i] == alien {
			break
		}
	}
	node.Aliens = append(node.Aliens[:i], node.Aliens[i+1:]...)
}

//CheckAndDestroy checks whether there are aliens fighting in the same city
func (g *Game) CheckAndDestroy() {
	for _, city := range g.AlienLocations {
		aliens := g.CityMap[city].Aliens
		if len(aliens) < 2 {
			continue
		}
		log.Printf("!!!!!!City %s has been destroyed by aliens: %s !!!!!!", city, strings.Join(aliens, " "))
		for _, alien := range aliens {
			delete(g.AlienLocations, alien)
		}
		g.DestroyCity(city)
	}
}

//DestroyCity cuts the path(s) to neighbor(s)
func (g *Game) DestroyCity(cn string) {
	cityNode := g.CityMap[cn]
	if len(cityNode.Aliens) < 2 {
		log.Panic("city has less than 2 aliens")
	}
	if cityNode.East != nil {
		eastNeighbor := cityNode.East
		cityNode.East, eastNeighbor.West = nil, nil
	}
	if cityNode.West != nil {
		westNeighbor := cityNode.West
		cityNode.West, westNeighbor.East = nil, nil
	}
	if cityNode.North != nil {
		northNeighbor := cityNode.North
		cityNode.North, northNeighbor.South = nil, nil
	}
	if cityNode.South != nil {
		southNeighbor := cityNode.South
		cityNode.South, southNeighbor.North = nil, nil
	}
}
